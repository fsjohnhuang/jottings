## 类加载的流程
加载（Loading）<br/>
链接（Linking）：验证（Verification）、准备（Preparation）、解析（Resolution）(可以在初始化后再执行，称为动态绑定或晚期绑定)<br/>
初始化（Initialization）<br/>
使用（Using）<br/>
卸载（Unloading）<br/>

加载、链接和初始化是交叉混合式进行的，不是加载完成后执行链接，也不是链接完成后执行初始化的。<br/>
HotSpot中通过`-XX:+TraceClassLoading`可以输出类加载的信息。<br/>

## 主动引用
JVM规范规定以下5种情况，则必须执行初始化（加载、链接自然会在之前进入执行状态）<br/>
1. 遇到new, getstatic, putstatic或invokestatic这4条字节码指令时，若类没有进行过初始化，则需要先触发初始化。对应的Java代码为通过关键字new一个实例，读或写一个类变量，调用类方法。<br/>
2. 使用`java.lang.reflect`包中的方法操作类时，若类没有进行过初始化，则需要先触发初始化。<br/>
3. 当初始化一个类时，若其父类还没初始化则会先初始化父类。<br/>
4. 当虚拟机启动时，虚拟机会初始化入口函数所在的类。<br/>
5. JDK1.7增加动态语言的支持。如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果是REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，而这个句柄所在的类没有进行初始化，则需要先触发初始化。<br/>

除了上述5种情况外，其他引用类的方式是不会触发初始化的，并称为被动引用。<br/>
通过子类访问父类静态字段不会导致子类初始化，仅仅会导致父类初始化。<br/>
Java代码中创建数组对象，不会导致数组的组件类（如SuperClass[]的组件类为SuperClass）初始化。因为创建数组类的字节码指令是newarray。<br/>
类A访问类B的静态常量不会导致类B的初始化。因为在编译阶段会将类使用到的常量直接存储到自身常量池的引用中，因此实际上运行时类A访问的是自身的常量与类B无关系。<br/>

## 加载（Loading）
除了`/lib`下如rt.jar等类外由内置于JVM的启动类加载器（BootstrapClassLoader）加载外，其他类均有JVM外置的继承于`java.lang.ClassLoader`的类加载器实现加载操作。<br/>
因此整个加载过程，仅加载阶段是Java程序员可控制的，而其他阶段则是由JVM完全控制。<br/>
分为三个步骤：<br/>
1. 通过一个类的全限定名来获取定义此类的二进制字节流（源是多样的，可以是JAR、EAR、WAR，或网络中数据库中获取，也可以是通过动态代理技术来动态生成代理类）；<br/>
  在读取类的二进制字节流时，链接阶段的验证子阶段的文件格式验证已经开始了，文件格式验证用于保证读取进入来的数据能够正确解析并存储于方法区中（Class文件格式由JVM规范规定，而方法区的数据结构由JVM自行决定），只有通过文件格式验证后才能存储到方法区中。<br/>
  若验证失败则抛出`java.lang.VerifyError`或其子类异常。<br/> 
  
2. 将字节流所代表的静态存储结构（Class文件结构）转化为方法区的运行时数据结构。<br/>

3. 在内存中生成一个代表类或接口的`java.lang.Class`对象，作为操作该类或接口在方法区中数据的入口。<br/>
  HotSpot的Class对象存储在方法区中。

对于数组类型的加载，是加载数组的组件类型，然后由JVM自动创建数组类型。如SuperClass[]则加载LSuperClass类，然后由JVM创建[LSuperClass数组类。也就是说Java将数组封装成一个类，对数组的操作均被封装成数组对象的方法，如size()就是获取数组的长度。<br/>


## 链接（Linking）
### 验证（Verification）
首先对于被反复使用和验证过的类，验证过程是非必要的。可以通过`-Xverify:none`来关闭验证，可缩短虚拟机加载的时间。<br/>
1. 文件格式验证<br/>
  操作对象：二进制字节流<br/>
  目的：验证是否符合Class文件格式的规范。<br/>
2. 元数据验证<br/>
  操作对象：方法区中的类或接口的信息<br/>
  目的：对字节码描述的类的元数据信息进行语义分析，保证符合Java语言规范。<br/>
  类的元数据信息包括：<br/> 
   1. 类的父类信息（全限定名、修饰符等）;<br/> 
   2. 类的父类字段、方法信息；<br/> 
   3. 类的信息（全限定名、修饰符等）;<br/> 
   4. 类的字段、方法信息；<br/> 
   等等。**注意：不含方法体信息！**<br/>
3. 字节码验证<br/>
  操作对象：方法区中的类或接口信息的Code属性<br/>
  目的：对方法体语句进行语义分析，保证方法运行时不会出现危害JVM安全的事件<br/>
  由于这种语义分析需要执行类似于下列等检查，因此需要进行类型推导这一十分耗时的操作。<br/>
  1. 检查操作数栈的数据类型与指令的操作数类型兼容；<br/>
  2. 检查跳转指令不会跳转到方法体外的字节码指令上；<br/>
  3. 检查类型转换是安全的。<br/>
  JDK1.6在Code属性中添加了一个StackMapTable的属性，用于描述方法中所有基本块（Basic Block，按控制流拆分的代码块）开始时本地变量表和操作数栈引用的状态。然后字节码验证时则进行类型检查而不是类型推导，从而提高验证的性能。可通过`-XX:-UseSplitVerifier`来关闭类型检查回归到类型推导，或通过`-XX:+FailOverToOldVerifier`来设置当类型检查失败就采用类型推导。<br/>
  JDK1.7则只能采用类型检查了。<br/>
  但StackMapTable的数据依然可以被篡改，而这就是JVM开发团队需要考虑的了。<br/>
4. 符号引用验证<br/>
  操作对象：方法区中的类或接口信息<br>
  目的：对类的符号引用和类的实际信息（类、字段、方法等）进行验证，保证符号引用可成功解析为直接引用，并当前类可以成功访问直接引用<br/>
  在执行链接阶段的解析子阶段时，会对符号引用进行符号引用验证，验证包括以下等内容：<br/>
  1. 通过符号引用中字符串描述的全限定名是否可以在方法区中找到对应的类。<br/>
  2. 通过符号引用中对字段、方法的简单名和描述符是否可以在方法区找到对应的字段和方法。<br/>
  3. 当前实例是否有权限访问符号引用的类、字段和方法。<br/>
  若验证失败则会抛出`java.lang.IncompatibleClassChangeError`的子类`java.lang.IllegalAccessError`、`java.lang.NoSuchFieldError`和`java.lang.NoSuchMethodError`等。<br/>

### 准备（Preparation）

### 解析（）

## 初始化（Initialization）
  类和接口均有初始化过程，实质上就是执行字节码中的`<clinit>`构造函数。<br/>
  类中静态字段和静态代码块均被代码重排到`<clinit>`函数中进行赋值等操作。并且父类必须已经初始化后再初始化子类<br/>
  接口的静态字段也被代码重排到`<clinit>`函数中进行赋值操作。但不要初始化该接口前必须其父接口完成了初始化，而是在真正使用到父接口（静态常量字段）时才触发初始化。



